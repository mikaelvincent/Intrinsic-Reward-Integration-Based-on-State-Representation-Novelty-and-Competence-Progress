#### 4.2.4 Implementation Details

All environments are accessed through a unified interface to streamline experimentation.

The main implementation notes include:
1. Software Frameworks
   - OpenAI Gym Wrappers
     - For Mountain Car, Bipedal Walker, Car Racing, and the MuJoCo tasks (Ant, Half Cheetah, Humanoid). Observations are returned as NumPy arrays, actions are either discrete (e.g., Mountain Car) or continuous (MuJoCo, Bipedal Walker, Car Racing).
   - MuJoCo Engine
     - Provides fast, stable physics simulation for high-dimensional tasks (Todorov et al., 2012). The environment seeds are set at each episode to randomize physical properties or initial robot states.
2. Observations and Preprocessing
   - State Vectors
     - For Mountain Car and MuJoCo tasks, raw numeric observations (position, velocity, angles) are directly used, optionally normalized by environment-specific bounds.
   - Image-Based
     - For Car Racing, 84×84 grayscale or 96×96 RGB frames are downsampled if needed. Minimal pixel-based preprocessing is applied (e.g., scaling to [0,1] or standardizing to zero mean, unit variance).
   - No Additional domain-specific features or noise filters are added, aside from partial randomization described above.
3. Action Discretization or Scaling
   - In discrete-action tasks (Mountain Car), actions are enumerated.
   - In continuous tasks (e.g., Bipedal Walker, MuJoCo domains), actions are scaled to [\(-1\), \(+1\)] or similar intervals. If an RL algorithm requires learning a mean and variance for a Gaussian policy, the final action is clipped to the environment's permissible range.
4. Episode Batching
   - Multiple parallel environment instances are often used to accelerate data collection. Each instance is seeded independently, ensuring broader coverage of possible domain configurations.
5. Reproducibility
   - To enable consistent experiments, a fixed set of seeds is designated for each environment. Logging includes the exact seed, environment version, and randomization parameters. By design, each run can be reproduced precisely by reloading these seeds, versions, and hyperparameters.

This unified approach guarantees consistent data handling and parallelization across diverse tasks, facilitating systematic evaluation of curiosity-driven or exploration-based methods under partially random conditions.
